\#\# Snippet 1: What is a Greedy Algorithm?   
A greedy algorithm builds a solution by making the best choice at each step without revisiting past decisions. It works only when local optima leads to a global optimum.

\#\# Snippet 2: Greedy Choice Property    
A problem has the greedy choice property if a locally optimal decision at each step leads to a globally optimal solution. This allows greedy algorithms to make immediate decisions without needing to revise earlier steps.

\#\# Snippet 3: Optimal Substructure    
A problem exhibits optimal substructure if its optimal solution can be built from optimal solutions of its subproblems. This property is required for both greedy algorithms and dynamic programming.

\#\# Snippet 4: Exchange Argument  
An additional argument that proves a greedy algorithm's correctness by showing that any optimal solution can be transformed into the greedy one without reducing its quality.

\#\# Snippet 5: Greedy vs Dynamic Programming    
Greedy makes the best immediate choice and never looks back. DP explores all options, stores results, and always finds the optimal solution if the problem allows it.

\#\# Snippet 6: Proving Correctness of Greedy Algorithms    
To prove a greedy algorithm is correct, show two things: (1) the problem has optimal substructure, and (2) the greedy choice property holds.

\#\# Snippet 7: Real-Life Greedy Applications    
Greedy strategies are used in cash withdrawal (minimum coins), job scheduling, routing (Dijkstra), and data compression (Huffman coding).

\#\# Snippet 8: When Greedy Algorithms Don’t Work    
Greedy algorithms fail when local decisions don’t lead to the best global outcome. Problems like 0/1 Knapsack, travelling salesman problem or coin change (with unusual denominations) require more complex methods.

